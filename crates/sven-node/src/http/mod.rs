// Copyright (c) 2024-2026 Martin Schröder <info@swedishembedded.com>
//
// SPDX-License-Identifier: Apache-2.0
//!
//! HTTP/WebSocket server for browser-based operator connections.
//!
//! # Route map
//!
//! | Method | Path             | Handler          | Auth required |
//! |--------|------------------|------------------|---------------|
//! | GET    | /ws              | WebSocket bridge | Yes           |
//! | POST   | /slack/events    | Slack webhook    | No (HMAC)     |
//! | POST   | /slack/<path>    | Custom webhook   | No (HMAC)     |
//! | GET    | /api/v1/sessions | List sessions    | Yes           |
//! | GET    | /healthz         | Health check     | No            |
//!
//! # TLS
//!
//! TLS is **on by default** using ECDSA P-256 certificates generated by
//! `rcgen` (pure Rust). The flag `insecure_dev_mode: true` in the config
//! disables TLS — the name is intentionally scary.
//!
//! When TLS is off a warning is logged on every startup.

pub mod auth;
pub mod security;
pub mod slack;
pub mod tls;
pub mod ws;

use std::{net::SocketAddr, time::Duration};

use axum::extract::ConnectInfo;

use anyhow::Context as _;
use axum::{
    extract::State,
    http::StatusCode,
    middleware,
    response::IntoResponse,
    routing::{get, post},
    Router,
};
use axum_server::tls_rustls::RustlsConfig;
use tower_http::limit::RequestBodyLimitLayer;
use tracing::{info, warn};

use crate::{config::HttpConfig, control::service::AgentHandle};
use auth::{AsAuthState, AuthState};
use security::{csrf_guard, security_headers};

/// Combined app state shared across all HTTP handlers.
#[derive(Clone)]
pub struct AppState {
    pub agent: AgentHandle,
    pub auth: AuthState,
}

impl AsAuthState for AppState {
    fn auth_state(&self) -> &AuthState {
        &self.auth
    }
}

/// Start the HTTP server.
///
/// Blocks until the server exits (or returns an error).
pub async fn serve(
    config: &HttpConfig,
    agent: AgentHandle,
    token_hash: crate::crypto::token::StoredToken,
    slack_states: Vec<slack::SlackWebhookState>,
) -> anyhow::Result<()> {
    let addr: SocketAddr = config
        .bind
        .parse()
        .map_err(|e| anyhow::anyhow!("invalid bind address {:?}: {e}", config.bind))?;

    let app_state = AppState {
        agent: agent.clone(),
        auth: AuthState::with_defaults(token_hash),
    };

    // Build Slack webhook routes (one per configured HTTP account).
    let mut slack_router = Router::new();
    for state in slack_states {
        slack_router = slack_router.route(
            "/slack/events",
            post(slack::slack_events_handler).with_state(state),
        );
    }

    // Routes that require bearer-token auth.
    let protected = Router::new()
        .route("/ws", get(ws_handler_entry))
        .route("/api/v1/sessions", get(list_sessions_handler))
        .layer(middleware::from_fn_with_state(
            app_state.clone(),
            auth::bearer_auth_mw::<AppState>,
        ));

    let app = Router::new()
        .route("/healthz", get(health_handler))
        .merge(slack_router)
        .merge(protected)
        .layer(middleware::from_fn(security_headers))
        .layer(middleware::from_fn(csrf_guard))
        .layer(RequestBodyLimitLayer::new(config.max_body_bytes))
        .with_state(app_state);

    // Graceful shutdown on Ctrl+C / SIGTERM.
    let handle = axum_server::Handle::new();
    let shutdown_handle = handle.clone();
    tokio::spawn(async move {
        shutdown_signal().await;
        info!("shutdown signal received — stopping HTTP server");
        shutdown_handle.graceful_shutdown(Some(Duration::from_secs(5)));
    });

    if config.insecure_dev_mode {
        warn!(
            "⚠  HTTP gateway running WITHOUT TLS (insecure_dev_mode: true). \
             Never use this in production."
        );
        axum_server::bind(addr)
            .handle(handle)
            .serve(app.into_make_service_with_connect_info::<SocketAddr>())
            .await?;
    } else {
        let cert_dir = config
            .tls_cert_dir
            .clone()
            .unwrap_or_else(tls::default_cert_dir);
        let tls_runtime = tls::load_or_generate(&cert_dir)?;

        info!(
            %addr,
            fingerprint = %tls_runtime.fingerprint_sha256,
            "HTTPS gateway listening (TLS 1.3, ECDSA P-256)",
        );
        info!(
            "Pin this fingerprint in your mobile app to prevent MITM: {}",
            tls_runtime.fingerprint_sha256,
        );

        let rustls_config =
            RustlsConfig::from_pem_file(&tls_runtime.cert_path, &tls_runtime.key_path)
                .await
                .context("loading TLS config from PEM files")?;

        axum_server::bind_rustls(addr, rustls_config)
            .handle(handle)
            .serve(app.into_make_service_with_connect_info::<SocketAddr>())
            .await?;
    }

    Ok(())
}

async fn shutdown_signal() {
    let ctrl_c = async {
        tokio::signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    {
        let mut sigterm = tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())
            .expect("failed to install SIGTERM handler");
        tokio::select! {
            _ = ctrl_c => {},
            _ = sigterm.recv() => {},
        }
    }

    #[cfg(not(unix))]
    ctrl_c.await;
}

// ── Handlers ──────────────────────────────────────────────────────────────────

async fn health_handler() -> impl IntoResponse {
    StatusCode::OK
}

/// WebSocket handler entry point — extracts agent and client IP from combined state.
async fn ws_handler_entry(
    ws: axum::extract::ws::WebSocketUpgrade,
    ConnectInfo(addr): axum::extract::ConnectInfo<SocketAddr>,
    State(state): State<AppState>,
) -> impl IntoResponse {
    ws.on_upgrade(move |socket| ws::handle_socket(socket, state.agent, addr))
}

async fn list_sessions_handler(State(state): State<AppState>) -> impl IntoResponse {
    use crate::control::protocol::ControlCommand;
    let _ = state.agent.send(ControlCommand::ListSessions).await;
    StatusCode::ACCEPTED
}
