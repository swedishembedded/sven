// Copyright (c) 2024-2026 Martin Schröder <info@swedishembedded.com>
//
// SPDX-License-Identifier: MIT
//!
//! `sven-node` — secure remote-control gateway for sven agents.
//!
//! The gateway exposes a running [`sven_core::Agent`] to remote operators
//! over two transport paths:
//!
//! - **Native clients** (mobile apps, remote CLI): libp2p with Noise
//!   encryption and Ed25519 identity — the `sven-pair://` pairing flow
//!   authorises devices.
//! - **Browser clients** (web UI): HTTPS + WebSocket with bearer-token
//!   authentication and TLS 1.3 certificates auto-generated by `rcgen`.
//! - **Slack**: Socket Mode (outbound WebSocket, no inbound port) or HTTP
//!   webhook with HMAC-SHA256 signature verification.
//!
//! # Quick start
//!
//! ```bash
//! # Start the gateway (TLS cert auto-generated, token printed once):
//! sven gateway start
//!
//! # Authorize a mobile device that shows a sven-pair:// URI:
//! sven gateway pair "sven-pair://12D3KooW..."
//!
//! # Revoke a device:
//! sven gateway revoke 12D3KooW...
//!
//! # Replace the HTTP bearer token:
//! sven gateway regenerate-token
//!
//! # Print the active configuration (YAML):
//! sven gateway show-config
//! ```
//!
//! # Architecture
//!
//! ```text
//! ┌──────────────────────────────────────────────────────────────────┐
//! │  Native clients (mobile, CLI)     Browser-class clients          │
//! │  Ed25519 identity                 Bearer token (256-bit)         │
//! │  libp2p Noise (always on)         rustls TLS 1.3 (always on)     │
//! │  Relay + DCUtR (built-in)         HTTPS/WSS only                 │
//! └──────────┬───────────────────────────────┬─────────────────────┘
//!            │ /sven/control/1.0.0            │ axum HTTPS
//!            ▼                               ▼
//!    ┌────────────────────────────────────────────┐
//!    │             sven-node                   │
//!    │  P2PControlNode  │   HTTP (axum+rustls)    │
//!    │  PeerAllowlist   │   Auth middleware        │
//!    │  (deny-default)  │   CSRF guard             │
//!    │                  │   Security headers       │
//!    │                  │   Slack integration      │
//!    └──────────────────┴──────────────────────────┘
//!                        │
//!                  ControlService
//!                        │
//!                   sven-core Agent
//! ```
//!
//! # Configuration
//!
//! Configuration is YAML (never TOML). The gateway merges layers from:
//!
//! 1. `/etc/sven/gateway.yaml`
//! 2. `~/.config/sven/gateway.yaml`
//! 3. `.sven/gateway.yaml` (workspace-local override)
//! 4. Path given via `--config` flag
//!
//! Minimal example (`~/.config/sven/gateway.yaml`):
//!
//! ```yaml
//! http:
//!   bind: "127.0.0.1:18790"   # loopback-only by default
//!   insecure_dev_mode: false   # TLS is on — keep it that way
//!
//! p2p:
//!   listen: "/ip4/0.0.0.0/tcp/0"
//!   keypair_path: "~/.config/sven/gateway/keypair"
//!
//! slack:
//!   accounts:
//!     - mode: socket            # outbound WebSocket, no inbound port needed
//!       app_token: "xapp-..."
//!       bot_token: "xoxb-..."
//! ```
//!
//! # WebSocket wire format (browser clients)
//!
//! Connect to `wss://<host>:<port>/ws` with `Authorization: Bearer <token>`.
//! Send and receive JSON-encoded [`control::protocol::ControlCommand`] /
//! [`control::protocol::ControlEvent`] messages as text frames.
//!
//! ```json
//! // Operator → agent: start a new session
//! {"type":"new_session","id":"<uuid>","mode":"agent","working_dir":null}
//!
//! // Operator → agent: send input to a session
//! {"type":"send_input","session_id":"<uuid>","text":"refactor the auth module"}
//!
//! // Agent → operator: streaming text delta
//! {"type":"output_delta","session_id":"<uuid>","delta":"Sure, let me","role":"assistant"}
//!
//! // Agent → operator: tool call needs approval
//! {"type":"tool_needs_approval","session_id":"<uuid>","call_id":"c1","tool_name":"run_terminal_command","args":{...}}
//!
//! // Operator → agent: approve the tool call
//! {"type":"approve_tool","session_id":"<uuid>","call_id":"c1"}
//! ```
//!
//! # P2P wire format (native clients)
//!
//! Use the `request_response` behaviour with the `/sven/control/1.0.0`
//! protocol. Each exchange is:
//!
//! - **Request**: CBOR-encoded [`p2p::handler::ControlP2pRequest`]
//!   (contains a [`control::protocol::ControlCommand`])
//! - **Response**: CBOR-encoded [`p2p::handler::ControlP2pResponse`]
//!   (contains `ok`, optional `error`, and buffered
//!   [`control::protocol::ControlEvent`]s since the last poll)
//!
//! Each message is length-prefixed: `[u32 BE length][CBOR payload]`.
//!
//! # Security defaults (opt-out, not opt-in)
//!
//! | Property                     | Default                              |
//! |------------------------------|--------------------------------------|
//! | HTTP TLS                     | **On** (disable: `insecure_dev_mode: true`) |
//! | TLS version                  | TLS 1.3 only                         |
//! | Certificate algorithm        | ECDSA P-256, 90-day validity         |
//! | P2P encryption               | Noise (always on, cannot disable)    |
//! | P2P peer authorization       | Deny-all by default                  |
//! | HTTP rate limiting           | 5 failures/minute → 60s lockout      |
//! | Token storage                | SHA-256 hash only (never plaintext)  |
//! | HTTP bind                    | `127.0.0.1` (loopback only)          |
//! | HSTS                         | 1 year, includeSubDomains            |
//! | CSP                          | Strict, no inline scripts            |
//! | Slack HTTP                   | HMAC-SHA256 + 5-min replay window    |
//! | Secret files                 | `0o600` permissions (Unix)           |

pub mod agent_builder;
pub mod config;
pub mod control;
pub mod crypto;
pub mod error;
pub mod http;
pub mod node;
pub mod p2p;
pub mod tools;

pub use config::{GatewayConfig, HttpConfig, P2pGatewayConfig, SlackConfig};
pub use control::service::AgentHandle;
pub use error::GatewayError;
pub use node::{build_agent_card, exec_task, list_peers, run};
