// Copyright (c) 2024-2026 Martin Schröder <info@swedishembedded.com>
//
// SPDX-License-Identifier: MIT
//!
//! HTTP/WebSocket server for browser-based operator connections.
//!
//! # Route map
//!
//! | Method | Path             | Handler          | Auth required |
//! |--------|------------------|------------------|---------------|
//! | GET    | /ws              | WebSocket bridge | Yes           |
//! | POST   | /slack/events    | Slack webhook    | No (HMAC)     |
//! | POST   | /slack/<path>    | Custom webhook   | No (HMAC)     |
//! | GET    | /api/v1/sessions | List sessions    | Yes           |
//! | GET    | /healthz         | Health check     | No            |
//!
//! # TLS
//!
//! TLS is **on by default** using ECDSA P-256 certificates generated by
//! `rcgen` (pure Rust). The flag `insecure_dev_mode: true` in the config
//! disables TLS — the name is intentionally scary.
//!
//! When TLS is off a warning is logged on every startup.

pub mod auth;
pub mod security;
pub mod slack;
pub mod tls;
pub mod ws;

use std::net::SocketAddr;

use axum::{
    Router,
    extract::State,
    http::StatusCode,
    middleware,
    response::IntoResponse,
    routing::{get, post},
};
use anyhow::Context as _;
use axum_server::tls_rustls::RustlsConfig;
use tower_http::limit::RequestBodyLimitLayer;
use tracing::{info, warn};

use crate::{
    config::HttpConfig,
    control::service::AgentHandle,
};
use auth::{AsAuthState, AuthState};
use security::{csrf_guard, security_headers};

/// Combined app state shared across all HTTP handlers.
#[derive(Clone)]
pub struct AppState {
    pub agent: AgentHandle,
    pub auth: AuthState,
}

impl AsAuthState for AppState {
    fn auth_state(&self) -> &AuthState { &self.auth }
}

/// Start the HTTP server.
///
/// Blocks until the server exits (or returns an error).
pub async fn serve(
    config: &HttpConfig,
    agent: AgentHandle,
    token_hash: crate::crypto::token::StoredToken,
    slack_states: Vec<slack::SlackWebhookState>,
) -> anyhow::Result<()> {
    let addr: SocketAddr = config.bind.parse()
        .map_err(|e| anyhow::anyhow!("invalid bind address {:?}: {e}", config.bind))?;

    let app_state = AppState {
        agent: agent.clone(),
        auth: AuthState::with_defaults(token_hash),
    };

    // Build Slack webhook routes (one per configured HTTP account).
    let mut slack_router = Router::new();
    for state in slack_states {
        slack_router = slack_router.route(
            "/slack/events",
            post(slack::slack_events_handler).with_state(state),
        );
    }

    // Routes that require bearer-token auth.
    let protected = Router::new()
        .route("/ws", get(ws_handler_entry))
        .route("/api/v1/sessions", get(list_sessions_handler))
        .layer(middleware::from_fn_with_state(app_state.clone(), auth::bearer_auth_mw::<AppState>));

    let app = Router::new()
        .route("/healthz", get(health_handler))
        .merge(slack_router)
        .merge(protected)
        .layer(middleware::from_fn(security_headers))
        .layer(middleware::from_fn(csrf_guard))
        .layer(RequestBodyLimitLayer::new(config.max_body_bytes))
        .with_state(app_state);

    if config.insecure_dev_mode {
        warn!(
            "⚠  HTTP gateway running WITHOUT TLS (insecure_dev_mode: true). \
             Never use this in production."
        );
        axum_server::bind(addr)
            .serve(app.into_make_service_with_connect_info::<SocketAddr>())
            .await?;
    } else {
        let cert_dir = config.tls_cert_dir.clone()
            .unwrap_or_else(tls::default_cert_dir);
        let tls_runtime = tls::load_or_generate(&cert_dir)?;

        info!(
            %addr,
            fingerprint = %tls_runtime.fingerprint_sha256,
            "HTTPS gateway listening (TLS 1.3, ECDSA P-256)",
        );
        info!(
            "Pin this fingerprint in your mobile app to prevent MITM: {}",
            tls_runtime.fingerprint_sha256,
        );

        let rustls_config = RustlsConfig::from_pem_file(
            &tls_runtime.cert_path,
            &tls_runtime.key_path,
        ).await
        .context("loading TLS config from PEM files")?;

        axum_server::bind_rustls(addr, rustls_config)
            .serve(app.into_make_service_with_connect_info::<SocketAddr>())
            .await?;
    }

    Ok(())
}

// ── Handlers ──────────────────────────────────────────────────────────────────

async fn health_handler() -> impl IntoResponse {
    StatusCode::OK
}

/// WebSocket handler entry point — extracts agent from combined state.
async fn ws_handler_entry(
    ws: axum::extract::ws::WebSocketUpgrade,
    State(state): State<AppState>,
) -> impl IntoResponse {
    ws.on_upgrade(move |socket| ws::handle_socket(socket, state.agent))
}

async fn list_sessions_handler(State(state): State<AppState>) -> impl IntoResponse {
    use crate::control::protocol::ControlCommand;
    let _ = state.agent.send(ControlCommand::ListSessions).await;
    StatusCode::ACCEPTED
}
